# SWアーキテクチャ設計書 (IVI負荷App)

---

## 改訂履歴

| 版 | 日付 | 作成者 | 変更内容 |
|:---:|:---:|:---:|:---|
| 1.0 | 2025-10-07 | Hieu | 初版作成 |

---

## 1. 概要

### 1.1. 本書の目的

本書は、`IVI負荷アプリ` (IVI Load App) のソフトウェアアーキテクチャを定義することを目的とする。本書は、アプリケーションの構造、コンポーネント、インターフェース、および動的な振る舞いを記述する。

### 1.2. システムにおける位置づけ

`IVI負荷アプリ`は、`Cockpit AI System`全体の一部である。このシステムには、`IVI負荷アプリ`の他に`Meter負荷アプリ`、`HUD負荷アプリ`といった他の負荷生成アプリケーションや、`AIアプリ`群が存在する。`IVI負荷アプリ`は、IVI（車載インフォテインメント）のUIを模倣しつつ、指定されたCPU/GPU負荷を生成し、さらに外部の`AIアプリ`からの指示に応じてUIを更新する責務を持つ。

### 1.3. 機能概要

本アプリケーションは、以下の主要機能を持つ。
- 静的なIVIホーム画面UIの表示
- 調整可能なCPU負荷生成機能
- 調整可能なGPU負荷生成機能
- 外部からのIPC通信による負荷レベルの遠隔制御
- 外部からのIPC通信によるUI表示の遠隔制御

### 1.4. 主要な非機能要求 (Main Non-Functional Requirements)

本アプリケーションは、MCDCシステムをシミュレートするため、以下の性能目標を達成する必要がある。

- **目標CPU負荷率:** 60%
- **目標GPU負荷率:** 40%
- **目標動作周波数:** 60fps

## 2. アーキテクチャ方針と制約事項

### 2.1. アーキテクチャ基本方針

- **レイヤードアーキテクチャ:** システムは、各層の独立性を高め、保守性を向上させるため、明確に定義された層（UI層、ロジック・状態層）に分割される。
- **状態管理:** アプリケーションの状態は一元管理される（`StateManagement`）。UIウィジェットは状態を直接変更せず、状態管理ユニットに変更を要求し、状態の変更に応じてUIを再描画する。
- **コンポーネントベース:** UIとロジックは、再利用可能で独立したコンポーネント（ユニット）として設計される。

### 2.2. 設計方針

- **フレームワーク:** `Flutter` を使用し、Windowsデスクトップアプリケーションを構築する。
- **CPU負荷生成:** CPU負荷は、メインのUIスレッドから分離された `Isolate` 上で計算処理をループ実行することで生成する。これにより、UIの応答性を維持しつつ、安定したCPU負荷をかける。
- **GPU負荷生成:** GPU負荷は、`Fragment Shader` を用いて複雑な描画処理を連続的に行わせることで生成する。

### 2.3. 制約事項

- **ハードウェア:** 開発および実行環境は `Windows` PCとする。
- **ソフトウェア:** `Flutter SDK` がインストールされている必要がある。

## 3. 機能要求 (ユースケース)

本アプリケーションが満たすべき機能要求は、以下のユースケースとして定義される。

| ID    | ユースケース名                               | アクター             |
|-------|----------------------------------------------|----------------------|
| UC-01 | ユーザーによるCPU負荷の手動調整              | ユーザー             |
| UC-02 | ユーザーによるGPU負荷の手動調整              | ユーザー             |
| UC-03 | 外部システムによるCPU負荷の遠隔調整          | 外部PC               |
| UC-04 | 外部システムによるGPU負荷の遠隔調整          | 外部PC               |
| UC-05 | AIアプリからのUI更新指示             | AIアプリ     |

詳細は、以下のドキュメントおよび図を参照。

- **ユースケース仕様書:** `../use-cases.md`
- **ユースケース図:** 
  ![Use Case Diagram](use-case-diagram.drawio.svg)

## 4. 機能ブロック設計

`IVI負荷アプリ`の内部機能ブロックと、外部システムとの関係を以下に示す。

![Functional Block Diagram](block-diagram.drawio.svg)

| ブロック名 | 所属層 | 概要 |
|---|---|---|
| `CpuLoadController` | UI層 | CPU負荷を調整するためのUIを描画し、ユーザー操作を処理する。 |
| `GpuLoadController` | UI層 | GPU負荷を調整するためのUIを描画し、ユーザー操作を処理する。 |
| `AiAppView` | UI層 | AIアプリからの指示に基づき、関連するUIを描画する。 |
| `StateManagement` | ロジック・状態層 | アプリケーション全体の状態（負荷率、UI状態等）を一元管理する。 |
| `IpcReceiver` | ロジック・状態層 | 外部システムからのIPC通信を受信する。 |
| `CpuLoadGenerator` | ロジック・状態層 | 指定された負荷率に基づき、CPU負荷を生成する。 |
| `GpuLoadGenerator` | ロジック・状態層 | 指定された負荷率に基づき、GPU負荷を生成する。 |

## 5. 静的構造設計 (クラス設計)

アプリケーションを構成する主要なクラス（ユニット）の構造と関係を以下に示します。

![Class Diagram](class-diagram.drawio.svg)

各クラス（ユニット）の責務、メソッド、プロパティに関する詳細な説明は、以下のドキュメントを参照してください。

- **ユニット仕様書:** `../unit-specifications.md`

## 6. 動的振る舞い設計 (シーケンス設計)

主要なユースケースにおける、各ユニット間のインタラクションを時系列で示す。

| シーケンス名 | 概要 |
|---|---|
| ユーザーによるCPU負荷変更 | ユーザーがUIを操作してCPU負荷を変更する際のシーケンス。 |
| ユーザーによるGPU負荷変更 | ユーザーがUIを操作してGPU負荷を変更する際のシーケンス。 |
| 外部PCによるCPU負荷変更 | 外部PCがIPC経由でCPU負荷を変更する際のシーケンス。 |
| 外部PCによるGPU負荷変更 | 外部PCがIPC経由でGPU負荷を変更する際のシーケンス。 |
| AI関連のUI更新 | AIアプリがIPC経由でUIの更新を指示する際のシーケンス。 |

### 6.1. ユーザーによるCPU負荷変更
![User CPU Load Change](sequence-diagram-user-cpu-load-change.drawio.svg)

### 6.2. ユーザーによるGPU負荷変更
![User GPU Load Change](sequence-diagram-user-gpu-load-change.drawio.svg)

### 6.3. 外部PCによるCPU負荷変更
![External CPU Load Change](sequence-diagram-ipc-cpu-load-change.drawio.svg)

### 6.4. 外部PCによるGPU負荷変更
![External GPU Load Change](sequence-diagram-ipc-gpu-load-change.drawio.svg)

### 6.5. AI関連のUI更新
![AI UI Update](sequence-diagram-ai-data.drawio.svg)

## 7. 外部インターフェース仕様

`IVI負荷アプリ`は、IPC通信を介して外部システムと連携する。

- **メッセージ形式:** テキストベースのキー・バリュー形式 (例: `key: value`)

### 7.1. 負荷制御メッセージ

- **送信元:** 外部PC
- **フォーマット例:**
  - `cpu_load: 50`
  - `gpu_load: 70`

### 7.2. UI更新指示メッセージ

- **送信元:** AIアプリ
- **フォーマット例:**
  - `show_icon: hand`
  - `hide_icon: hand`

## 8. 性能・実装方針

### 8.1. CPU負荷
- **制御方法:** `Isolate` 内での処理ループにおける計算量と待機時間（`sleep`）の比率を調整することで負荷を制御する。

### 8.2. GPU負荷
- **制御方法:** `Fragment Shader` に渡す `uniform` 変数を変更し、シェーダー内の計算の複雑さやループ回数を変えることで負荷を制御する。
